# -*- coding: utf-8 -*-
"""CS3110.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V-Yckwh3SY7eFe_DB3n-hu7rM9PNI6pY
"""

#Part 1 (40 pts) Recognize Python decimal integer
#Not our completed NFA, does not accept float points, hex, or oct integers
decimal_nfa = {
    'q0': {
        '0': ['q1'],
        '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'], '5': ['q2'],
        '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q1': {
        '0': ['q1']
    },
    'q2': {
        '0': ['q2'], '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'],
        '5': ['q2'], '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    }
}

start_state = 'q0'
final_states = {'q1', 'q2'}

def simulate_nfa(decimal_nfa, start_state, final_states, input_string):
    current_states = [start_state]
    for symbol in input_string:
        next_states = []
        for state in current_states:
            if symbol in decimal_nfa.get(state, {}):
                next_states.extend(decimal_nfa[state][symbol])
        current_states = next_states
        if not current_states:
            return False
    return any(state in final_states for state in current_states)

try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(decimal_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")

#opening file, testing inputs, and creating new file
try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(decimal_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")

#Part 2 (60 pts) Extending NFA to recognize Python octal and hexadecimal integers
#Not our completed NFA, Does not accept float point integers
extended_nfa = {
    'q3': {
        '': ['q4', 'q8', 'q0']
    },
    'q0': {
        '0': ['q1'],
        '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'], '5': ['q2'],
        '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q1': {
        '0': ['q1']
    },
    'q2': {
        '0': ['q2'], '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'],
        '5': ['q2'], '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q4': {
        '0': ['q5']
    },
    'q5': {
        'O': ['q6'], 'o': ['q6']
    },
    'q6': {
        '0': ['q7'], '1': ['q7'], '2': ['q7'], '3': ['q7'], '4': ['q7'],
        '5': ['q7'], '6': ['q7'], '7': ['q7']
    },
    'q7': {
        '0': ['q7'], '1': ['q7'], '2': ['q7'], '3': ['q7'], '4': ['q7'],
        '5': ['q7'], '6': ['q7'], '7': ['q7']
    },
    'q8': {
        '0': ['q9']
    },
    'q9': {
        'X': ['q10'], 'x': ['q10']
    },
    'q10': {
        '0': ['q11'], '1': ['q11'], '2': ['q11'], '3': ['q11'], '4': ['q11'], '5': ['q11'],
        '6': ['q11'], '7': ['q11'], '8': ['q11'], '9': ['q11'], 'A': ['q11'], 'B': ['q11'],
        'C': ['q11'], 'D': ['q11'], 'E': ['q11'], 'F': ['q11'], 'a': ['q11'], 'b': ['q11'],
        'c': ['q11'], 'd': ['q11'], 'e': ['q11'], 'f': ['q11']
    },
    'q11': {
        '0': ['q11'], '1': ['q11'], '2': ['q11'], '3': ['q11'], '4': ['q11'], '5': ['q11'],
        '6': ['q11'], '7': ['q11'], '8': ['q11'], '9': ['q11'], 'A': ['q11'], 'B': ['q11'],
        'C': ['q11'], 'D': ['q11'], 'E': ['q11'], 'F': ['q11'], 'a': ['q11'], 'b': ['q11'],
        'c': ['q11'], 'd': ['q11'], 'e': ['q11'], 'f': ['q11']
    }
}

start_state = 'q3'
final_states = {'q1', 'q2', 'q7', 'q11'}


def epsilon_transition(nfa, states):
    stack = list(states)
    while stack:
        state = stack.pop()
        if state in nfa and '' in nfa[state]:
            for next_state in nfa[state]['']:
                if next_state not in states:
                    states.append(next_state)
                    stack.append(next_state)
    return states

def simulate_nfa(extended_nfa, start_state, final_states, input_string):
    current_states = epsilon_transition(extended_nfa, [start_state])
    for symbol in input_string:
        next_states = []
        for state in current_states:
            if symbol in extended_nfa.get(state, {}):
                next_states.extend(extended_nfa[state][symbol])
        current_states = next_states
        current_states = epsilon_transition(extended_nfa, next_states)
        if not current_states:
            return False
    return any(state in final_states for state in current_states)

try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(extended_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")

#Part 3: FLOATING POINT NFA
#NFA transitions extracted from Jflap
#Our final, completed NFA with the extra credit

combined_nfa = {
    '0': {'0': ['1']  # only allows '0', not '01', '02', etc.
          },
    '1': {'0': ['1']  # allows multiple 0s (like '00'), if you want to allow that
          },
    '2': {'0': ['2'], '1': ['2'], '2': ['2'], '3': ['2'], '4': ['2'],
          '5': ['2'], '6': ['2'], '7': ['2'], '8': ['2'], '9': ['2']},
    '3': {'': ['8', '12', '4', '0']},
    '4': {'0': ['5']},
    '5': {'O': ['6'], 'o': ['6']},
    '6': {'0': ['7'], '1': ['7'], '2': ['7'], '3': ['7'], '4': ['7'], '5': ['7'], '6': ['7'], '7': ['7']},
    '7': {'0': ['7'], '1': ['7'], '2': ['7'], '3': ['7'], '4': ['7'], '5': ['7'], '6': ['7'], '7': ['7']},
    '8': {'0': ['9']},
    '9': {'X': ['10'], 'x': ['10']},
    '10': {'0': ['11'], '1': ['11'], '2': ['11'], '3': ['11'], '4': ['11'], '5': ['11'], '6': ['11'], '7': ['11'],
           '8': ['11'], '9': ['11'], 'A': ['11'], 'B': ['11'], 'C': ['11'], 'D': ['11'], 'E': ['11'], 'F': ['11'],
           'a': ['11'], 'b': ['11'], 'c': ['11'], 'd': ['11'], 'e': ['11'], 'f': ['11']},
    '11': {'0': ['11'], '1': ['11'], '2': ['11'], '3': ['11'], '4': ['11'], '5': ['11'], '6': ['11'], '7': ['11'],
           '8': ['11'], '9': ['11'], 'A': ['11'], 'B': ['11'], 'C': ['11'], 'D': ['11'], 'E': ['11'], 'F': ['11'],
           'a': ['11'], 'b': ['11'], 'c': ['11'], 'd': ['11'], 'e': ['11'], 'f': ['11']},
    '12': {'.': ['14'], '0': ['13'], '1': ['13'], '2': ['13'], '3': ['13'], '4': ['13'], '5': ['13'], '6': ['13'],
           '7': ['13'], '8': ['13'], '9': ['13']},
    '13': {'.': ['16'], '0': ['13'], '1': ['13'], '2': ['13'], '3': ['13'], '4': ['13'], '5': ['13'], '6': ['13'],
           '7': ['13'], '8': ['13'], '9': ['13'], 'E': ['20'], 'e': ['20'], '_': ['15']},
    '14': {'0': ['18'], '1': ['18'], '2': ['18'], '3': ['18'], '4': ['18'], '5': ['18'], '6': ['18'], '7': ['18'],
           '8': ['18'], '9': ['18']},
    '15': {'0': ['13'], '1': ['13'], '2': ['13'], '3': ['13'], '4': ['13'], '5': ['13'], '6': ['13'], '7': ['13'],
           '8': ['13'], '9': ['13']},
    '16': {'0': ['18'], '1': ['18'], '2': ['18'], '3': ['18'], '4': ['18'], '5': ['18'], '6': ['18'], '7': ['18'],
           '8': ['18'], '9': ['18'], '_': ['17']},
    '17': {'0': ['16'], '1': ['16'], '2': ['16'], '3': ['16'], '4': ['16'], '5': ['16'], '6': ['16'], '7': ['16'],
           '8': ['16'], '9': ['16']},
    '18': {'0': ['18'], '1': ['18'], '2': ['18'], '3': ['18'], '4': ['18'],
           '5': ['18'], '6': ['18'], '7': ['18'], '8': ['18'], '9': ['18'],
           'E': ['20'], 'e': ['20'], '_': ['19']},
    '19': {'0': ['18'], '1': ['18'], '2': ['18'], '3': ['18'], '4': ['18'], '5': ['18'], '6': ['18'], '7': ['18'],
           '8': ['18'], '9': ['18']},
    '20': {'+': ['21'], '-': ['21'], '0': ['22'], '1': ['22'], '2': ['22'], '3': ['22'], '4': ['22'], '5': ['22'],
           '6': ['22'], '7': ['22'], '8': ['22'], '9': ['22']},
    '21': {'0': ['22'], '1': ['22'], '2': ['22'], '3': ['22'], '4': ['22'], '5': ['22'], '6': ['22'], '7': ['22'],
           '8': ['22'], '9': ['22']},
    '22': {'0': ['22'], '1': ['22'], '2': ['22'], '3': ['22'], '4': ['22'], '5': ['22'], '6': ['22'], '7': ['22'],
           '8': ['22'], '9': ['22'], '_': ['23']},
    '23': {'0': ['22'], '1': ['22'], '2': ['22'], '3': ['22'], '4': ['22'], '5': ['22'], '6': ['22'], '7': ['22'],
           '8': ['22'], '9': ['22']}
}

start_state = '3'
final_states = {'1,', '2', '7', '11', '13', '16', '18', '22'}

def is_valid_python_literal(input_str):
    # Reject decimal literals with leading zeros, unless valid float, hex, or octal
    if (
        input_str.startswith("0") and
        len(input_str) > 1 and
        not input_str.startswith(("0o", "0O", "0x", "0X")) and
        not '.' in input_str and
        not 'e' in input_str and
        not 'E' in input_str
    ):
        return False
    return simulate_nfa(combined_nfa, start_state, final_states, input_str)

def epsilon_transition(nfa, states):
    closure = set(states)
    stack = list(states)
    while stack:
        state = stack.pop()
        if state in nfa and '' in nfa[state]:
            for next_state in nfa[state]['']:
                if next_state not in closure:
                    closure.add(next_state)
                    stack.append(next_state)
    return list(closure)

def simulate_nfa(extended_nfa, start_state, final_states, input_string):
    current_states = epsilon_transition(extended_nfa, [start_state])
    for symbol in input_string:
        next_states = []
        for state in current_states:
            if symbol in extended_nfa.get(state, {}):
                next_states.extend(extended_nfa[state][symbol])
        current_states = epsilon_transition(extended_nfa, next_states)
        if not current_states:
            return False
    return any(state in final_states for state in current_states)

# Test input
try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if is_valid_python_literal(input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")