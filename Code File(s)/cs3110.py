# -*- coding: utf-8 -*-
"""CS3110 (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QFXacVx6j5p-9__zVev0d9FBA2h7p1OE
"""

#Part 1 (40 pts) Recognize Python decimal integer
decimal_nfa = {
    'q0': {
        '0': ['q1'],
        '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'], '5': ['q2'],
        '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q1': {
        '0': ['q1']
    },
    'q2': {
        '0': ['q2'], '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'],
        '5': ['q2'], '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    }
}

start_state = 'q0'
final_states = {'q1', 'q2'}

def simulate_nfa(decimal_nfa, start_state, final_states, input_string):
    current_states = [start_state]
    for symbol in input_string:
        next_states = []
        for state in current_states:
            if symbol in decimal_nfa.get(state, {}):
                next_states.extend(decimal_nfa[state][symbol])
        current_states = next_states
        if not current_states:
            return False
    return any(state in final_states for state in current_states)

try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(decimal_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")

#opening file, testing inputs, and creating new file
try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(decimal_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")

#Part 2 (60 pts) Extending NFA to recognize Python octal and hexadecimal integers
extended_nfa = {
    'q3': {
        '': ['q4', 'q8', 'q0']
    },
    'q0': {
        '0': ['q1'],
        '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'], '5': ['q2'],
        '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q1': {
        '0': ['q1']
    },
    'q2': {
        '0': ['q2'], '1': ['q2'], '2': ['q2'], '3': ['q2'], '4': ['q2'],
        '5': ['q2'], '6': ['q2'], '7': ['q2'], '8': ['q2'], '9': ['q2']
    },
    'q4': {
        '0': ['q5']
    },
    'q5': {
        'O': ['q6'], 'o': ['q6']
    },
    'q6': {
        '0': ['q7'], '1': ['q7'], '2': ['q7'], '3': ['q7'], '4': ['q7'],
        '5': ['q7'], '6': ['q7'], '7': ['q7']
    },
    'q7': {
        '0': ['q7'], '1': ['q7'], '2': ['q7'], '3': ['q7'], '4': ['q7'],
        '5': ['q7'], '6': ['q7'], '7': ['q7']
    },
    'q8': {
        '0': ['q9']
    },
    'q9': {
        'X': ['q10'], 'x': ['q10']
    },
    'q10': {
        '0': ['q11'], '1': ['q11'], '2': ['q11'], '3': ['q11'], '4': ['q11'], '5': ['q11'],
        '6': ['q11'], '7': ['q11'], '8': ['q11'], '9': ['q11'], 'A': ['q11'], 'B': ['q11'],
        'C': ['q11'], 'D': ['q11'], 'E': ['q11'], 'F': ['q11'], 'a': ['q11'], 'b': ['q11'],
        'c': ['q11'], 'd': ['q11'], 'e': ['q11'], 'f': ['q11']
    },
    'q11': {
        '0': ['q11'], '1': ['q11'], '2': ['q11'], '3': ['q11'], '4': ['q11'], '5': ['q11'],
        '6': ['q11'], '7': ['q11'], '8': ['q11'], '9': ['q11'], 'A': ['q11'], 'B': ['q11'],
        'C': ['q11'], 'D': ['q11'], 'E': ['q11'], 'F': ['q11'], 'a': ['q11'], 'b': ['q11'],
        'c': ['q11'], 'd': ['q11'], 'e': ['q11'], 'f': ['q11']
    }
}

start_state = 'q3'
final_states = {'q1', 'q2', 'q7', 'q11'}


def epsilon_transition(nfa, states):
    stack = list(states)
    while stack:
        state = stack.pop()
        if state in nfa and '' in nfa[state]:
            for next_state in nfa[state]['']:
                if next_state not in states:
                    states.append(next_state)
                    stack.append(next_state)
    return states

def simulate_nfa(extended_nfa, start_state, final_states, input_string):
    current_states = epsilon_transition(extended_nfa, [start_state])
    for symbol in input_string:
        next_states = []
        for state in current_states:
            if symbol in extended_nfa.get(state, {}):
                next_states.extend(extended_nfa[state][symbol])
        current_states = next_states
        current_states = epsilon_transition(extended_nfa, next_states)
        if not current_states:
            return False
    return any(state in final_states for state in current_states)

try:
    with open("in_ans.txt", "r") as infile, open("out.txt", "w") as outfile:
        for line in infile:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            input_str = parts[0]
            expected = parts[1].upper()
            actual = "ACCEPT" if simulate_nfa(extended_nfa, start_state, final_states, input_str) else "REJECT"
            result = "PASS" if actual == expected else "FAIL"
            output_line = f"Input: '{input_str}' | Expected: {expected} | Actual: {actual} | {result}\n"
            outfile.write(output_line)
            print(output_line, end="")
except FileNotFoundError:
    print("Could not find 'in_ans.txt'.")
